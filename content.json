[{"title":"tensorflow.train.learning_rate_decay()","date":"2017-03-20T14:01:43.000Z","path":"2017/03/20/tensorflow-train-learning-rate-decay/","text":"学习udacity/3_regularization.ipynb时，发现tf.train.exponential_decay()函数，阅读源码，大概知道意思： 源码截取如下： 1234567891011121314151617def exponential_decay(learning_rate, global_step, decay_steps, decay_rate, staircase=False, name=None): if global_step is None: raise ValueError(\"global_step is required for exponential_decay.\") with ops.name_scope(name, \"ExponentialDecay\", [learning_rate, global_step, decay_steps, decay_rate]) as name: learning_rate = ops.convert_to_tensor(learning_rate, name=\"learning_rate\") dtype = learning_rate.dtype global_step = math_ops.cast(global_step, dtype) decay_steps = math_ops.cast(decay_steps, dtype) decay_rate = math_ops.cast(decay_rate, dtype) p = global_step / decay_steps if staircase: p = math_ops.floor(p) return math_ops.multiply(learning_rate, math_ops.pow(decay_rate, p), name=name) 看注释及代码可知 $$decayed\\ learning\\ rate = learning\\ rate \\times decay\\ rate ^ {global\\ step / decay\\ steps}$$ 即每隔global_step步进行一次递减，递减的方式为上一个learing_rate乘上decay_rate。由此可见，使用该方法下降learning_rate可使其迅速减小。 同时在Problem 4中，我使用了5层神经网络，用了L2正则以及dropout。我发现增加网络的层数并没有显著提高正确率，增加batch_size却可以提高正确率至96.4%。","tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"},{"name":"Machine learning","slug":"Machine-learning","permalink":"http://yoursite.com/tags/Machine-learning/"}]},{"title":"Bug日记","date":"2017-03-13T10:24:50.000Z","path":"2017/03/13/Bug日记/","text":"得到了一个iPod并希望在上面调试程序，但是总是显示App installation failed - There was an error communicating with your device.在官网上并没有搜索在解决方案。最后将iPod强行恢复出厂设置，bug fix！","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"制作POP翻页动画","date":"2016-07-26T12:16:59.000Z","path":"2016/07/26/制作POP翻页动画/","text":"我利用了POP库制作了简单的广告展示的翻页效果： yanshi 源码在这里 大致思路首先简单分析一下动画效果：我们使用了旋转以及平移两个动画效果，通过动图可以看到：通过手指拖动(pan)，图片在平移的同时绕着自身中轴线旋转。那么怎么让图片绕着中轴线旋转呢？可以使用POPBasicAnimation中的kPOPLayerRotaionY制作旋转动画，中轴线的位置为锚点的位置，可以通过anchorPoint、anchorPointZ以及position共同确定锚点的三维坐标。至于anchorPoint与position如何共同确定绝对坐标可以参照博客，简单来说：锚点是标志一个layer位置的点，anchorPoint是锚点在该layer的相对坐标，而positon是锚点在superView中的绝对坐标。沿x轴的平移效果可以通过POPBasicAnimaition的kPOPLayerPositionX来实现。旋转的角度以及平移的距离都与手指拖动(pan)的距离有关。 源码分析首先初始化五张图片，设置不同的位置，以及不同的旋转角度。在画面中只显示3张，但为了左右拖动时有图片补位，这里初始化5张。 12345678910111213141516171819202122- (void)initPictures &#123; for (int i = 0; i&lt;5; i++) &#123; UIImageView *imgView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:[pictureNames objectAtIndex:i]]]; imgView.frame = CGRectMake(0, 0, 319, 187); imgView.layer.anchorPoint = CGPointMake(0.5, 0.5); imgView.layer.anchorPointZ = 100.0f; imgView.layer.position = CGPointMake(-62+i*287, 374/4+30); imgView.layer.transform = [self setTransform3D]; imgView.userInteractionEnabled = YES; POPBasicAnimation *initRotationAnimation = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerRotationY]; initRotationAnimation.duration = 0; initRotationAnimation.toValue = @((2-i)*M_PI/6); [imgView.layer pop_addAnimation:initRotationAnimation forKey:@&quot;initRotation&quot;]; [self showImageAndReflection:imgView]; [imgViews addObject:imgView]; [self.view addSubview:imgView]; &#125;&#125; 这里通过showImageAndReflection函数来设置图片的倒影： 12345678910111213141516171819202122232425262728293031- (void)showImageAndReflection:(UIImageView *)view &#123; // 制作reflection CALayer *layer = view.layer; CALayer *reflectLayer = [CALayer layer]; reflectLayer.contents = layer.contents; reflectLayer.bounds = layer.bounds; reflectLayer.position = CGPointMake(layer.bounds.size.width/2, layer.bounds.size.height*1.5); reflectLayer.transform = CATransform3DMakeRotation(M_PI, 1, 0, 0); // 给该reflection加个半透明的layer CALayer *blackLayer = [CALayer layer]; blackLayer.backgroundColor = [UIColor whiteColor].CGColor; blackLayer.bounds = reflectLayer.bounds; blackLayer.position = CGPointMake(blackLayer.bounds.size.width/2, blackLayer.bounds.size.height/2); blackLayer.opacity = 0.6; [reflectLayer addSublayer:blackLayer]; // 给该reflection加个mask CAGradientLayer *mask = [CAGradientLayer layer]; mask.bounds = reflectLayer.bounds; mask.position = CGPointMake(mask.bounds.size.width/2, mask.bounds.size.height/2); mask.colors = [NSArray arrayWithObjects: (__bridge id)[UIColor clearColor].CGColor, (__bridge id)[UIColor whiteColor].CGColor, nil]; mask.startPoint = CGPointMake(0.5, 0.65); mask.endPoint = CGPointMake(0.5, 1); reflectLayer.mask = mask; // 作为layer的sublayer [layer addSublayer:reflectLayer];&#125; 代码参考这里 随后设置拖动手势UIPanGestureRecognizer并绑定panAllHandle函数，将手势绑定在当前view上。 12UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(panAllHandle:)];[self.view addGestureRecognizer:panGesture]; 处理函数panAllHandle为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138- (void)panAllHandle:(UIPanGestureRecognizer *)recognizer &#123; CGPoint location = [recognizer locationInView:self.view]; if (recognizer.state == UIGestureRecognizerStateBegan) &#123; num = location.x; &#125; NSMutableArray *rotationAnimations = [[NSMutableArray alloc]init]; NSMutableArray *moveAnimations = [[NSMutableArray alloc]init]; NSMutableArray *rotationEndAnimations = [[NSMutableArray alloc]init]; NSMutableArray *moveEndAnimations = [[NSMutableArray alloc]init]; for (int i = 0; i&lt;5; i++) &#123; POPBasicAnimation *rotationAnimation = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerRotationY]; rotationAnimation.duration = 0.01; POPBasicAnimation *moveAnimation = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerPositionX]; moveAnimation.duration = 0.01; [rotationAnimations addObject:rotationAnimation]; [moveAnimations addObject:moveAnimation]; &#125; if (YES) &#123; CGFloat percent = M_PI / (6*287); POPBasicAnimation *rotationAnimation = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerRotationY]; rotationAnimation.duration = 0.01; NSLog(@&quot;%f, %lu&quot;,location.x, (unsigned long)num); POPBasicAnimation *moveAnimation = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerPositionX]; moveAnimation.duration = 0.01; if ((location.x-num)&gt;350) &#123; for (int i = 0; i&lt;4; i++) &#123; POPBasicAnimation *rotation = [rotationAnimations objectAtIndex:i]; rotation.toValue = @(-(350)*percent+(2-i)*M_PI/6); POPBasicAnimation *move = [moveAnimations objectAtIndex:i]; move.toValue = @(350-62+i*287); UIImageView *imgView = [imgViews objectAtIndex:i]; [imgView.layer pop_addAnimation:rotation forKey:@&quot;rotation&quot;]; [imgView.layer pop_addAnimation:move forKey:@&quot;move&quot;]; &#125; &#125; else if ((location.x-num)&lt;-350) &#123; for (int i = 1; i&lt;5; i++) &#123; POPBasicAnimation *rotation = [rotationAnimations objectAtIndex:i]; rotation.toValue = @(-(-350)*percent+(2-i)*M_PI/6); POPBasicAnimation *move = [moveAnimations objectAtIndex:i]; move.toValue = @(-350-62+i*287); UIImageView *imgView = [imgViews objectAtIndex:i]; [imgView.layer pop_addAnimation:rotation forKey:@&quot;rotation&quot;]; [imgView.layer pop_addAnimation:move forKey:@&quot;move&quot;]; &#125; &#125; else if ((location.x - num)&gt;0) &#123; for (int i = 0; i&lt;4; i++) &#123; POPBasicAnimation *rotation = [rotationAnimations objectAtIndex:i]; rotation.toValue = @(-(location.x-num)*percent+(2-i)*M_PI/6); POPBasicAnimation *move = [moveAnimations objectAtIndex:i]; move.toValue = @(location.x-num-62+i*287); UIImageView *imgView = [imgViews objectAtIndex:i]; [imgView.layer pop_addAnimation:rotation forKey:@&quot;rotation&quot;]; [imgView.layer pop_addAnimation:move forKey:@&quot;move&quot;]; &#125; &#125; else if ((location.x - num)&lt;=0) &#123; for (int i = 1; i&lt;5; i++) &#123; POPBasicAnimation *rotation = [rotationAnimations objectAtIndex:i]; rotation.toValue = @(-(location.x-num)*percent+(2-i)*M_PI/6); POPBasicAnimation *move = [moveAnimations objectAtIndex:i]; move.toValue = @(location.x-num-62+i*287); UIImageView *imgView = [imgViews objectAtIndex:i]; [imgView.layer pop_addAnimation:rotation forKey:@&quot;rotation&quot;]; [imgView.layer pop_addAnimation:move forKey:@&quot;move&quot;]; &#125; &#125; if (recognizer.state == UIGestureRecognizerStateEnded || recognizer.state == UIGestureRecognizerStateCancelled) &#123; for (int i = 0; i&lt;5; i++) &#123; POPSpringAnimation *recoverAnimation = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerRotationY]; recoverAnimation.springBounciness = 18.0f; recoverAnimation.dynamicsMass = 2.0f; recoverAnimation.dynamicsTension = 200; POPSpringAnimation *recover = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerPositionX]; recover.springBounciness = 18.0f; recover.dynamicsMass = 2.0f; recover.dynamicsTension = 200; [rotationEndAnimations addObject:recoverAnimation]; [moveEndAnimations addObject:recover]; &#125; POPSpringAnimation *recoverAnimation = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerRotationY]; recoverAnimation.springBounciness = 18.0f; recoverAnimation.dynamicsMass = 2.0f; recoverAnimation.dynamicsTension = 200; // initialLocation = -img.frame.origin.x-img.frame.size.width/2; if ((location.x-num)&gt;50) &#123; for (int i = 0; i&lt;4; i++) &#123; POPBasicAnimation *rotation = [rotationEndAnimations objectAtIndex:i]; rotation.toValue = @(-(287)*percent+(2-i)*M_PI/6); POPBasicAnimation *move = [moveEndAnimations objectAtIndex:i]; move.toValue = @(287-62+i*287); UIImageView *imgView = [imgViews objectAtIndex:i]; [imgView.layer pop_addAnimation:rotation forKey:@&quot;rotation&quot;]; [imgView.layer pop_addAnimation:move forKey:@&quot;move&quot;]; &#125; [self moveRight]; &#125; else if ((location.x-num)&lt;-50) &#123; for (int i = 1; i&lt;5; i++) &#123; POPBasicAnimation *rotation = [rotationEndAnimations objectAtIndex:i]; rotation.toValue = @(-(-287)*percent+(2-i)*M_PI/6); POPBasicAnimation *move = [moveEndAnimations objectAtIndex:i]; move.toValue = @(-287-62+i*287); UIImageView *imgView = [imgViews objectAtIndex:i]; [imgView.layer pop_addAnimation:rotation forKey:@&quot;rotation&quot;]; [imgView.layer pop_addAnimation:move forKey:@&quot;move&quot;]; &#125; [self moveLeft]; &#125; else &#123; for (int i = 0; i&lt;5; i++) &#123; POPBasicAnimation *rotation = [rotationEndAnimations objectAtIndex:i]; rotation.toValue = @((2-i)*M_PI/6); POPBasicAnimation *move = [moveEndAnimations objectAtIndex:i]; move.toValue = @(-62+i*287); UIImageView *imgView = [imgViews objectAtIndex:i]; [imgView.layer pop_addAnimation:rotation forKey:@&quot;rotation&quot;]; [imgView.layer pop_addAnimation:move forKey:@&quot;move&quot;]; &#125; &#125; &#125; &#125;&#125; 由于重复的动画过多，这里只解释其中两种：初始化旋转以及平移函数,duration代表持续时间。 1234POPBasicAnimation *rotationAnimation = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerRotationY];rotationAnimation.duration = 0.01;POPBasicAnimation *moveAnimation = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerPositionX];moveAnimation.duration = 0.01; 通过position.x与num的差值，获得拖动的x轴方向距离。根据该距离设置好旋转动画旋转的角度，以及平移动画平移的距离。 12rotation.toValue = @(-(location.x-num)*percent+(2-i)*M_PI/6);move.toValue = @(location.x-num-62+i*287); 最后将动画绑定在图片上： 12[imgView.layer pop_addAnimation:rotation forKey:@&quot;rotation&quot;];[imgView.layer pop_addAnimation:move forKey:@&quot;move&quot;]; 这样一个图片的动画就完成了。最后推广在到所有图片上，并为拖动距离添加一定的阈值即可完成动画。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"POP","slug":"POP","permalink":"http://yoursite.com/tags/POP/"}]},{"title":"将cocos工程加入到iOS工程中","date":"2016-07-05T12:43:50.000Z","path":"2016/07/05/将cocos工程加入到iOS工程中/","text":"本文讨论的是这样一种情况：一个iOS应用中有一个游戏，iOS程序与游戏是单独开发，并且游戏是用cocos2dx引擎。这样在开发结束时，我们需要将这两个工程合到一起，换句话说就是讲cocos游戏嵌入到iOS应用中。 大致思路我的解决方案的大致思路是这样的：将cocos引擎添加到iOS工程中，在合适的位置进入cocos游戏界面。 步骤向iOS工程中加入文件首先按cocos官网上的方法生成cocos工程，向iOS工程中添加cocos工程中的Classes/、proj.ios_mac/ios/、resources复制到iOS工程的文件夹中。向工程中添加文件：Classes/、ios/、cocos2d/build/cocos2d_libs.xcodeproj。 更改工程设置1.向工程中添加如图所示的库 Markdown 2.向 Building Setting&gt;Header Search Paths 中添加项 Markdown 3.在 Building Setting 中更改工程设置 Markdown Markdown 4.删除原工程的 main.m、AppDelegate.h/m 文件 更改工程入口具体设置参照博客，大致的思路就是修改cocos工程的入口AppController文件，在需要嵌入游戏的位置初始化RootViewController即可。 合并后的工程在这里.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"cocos2dx","slug":"cocos2dx","permalink":"http://yoursite.com/tags/cocos2dx/"}]},{"title":"开始我的hexo博客","date":"2016-03-23T08:05:00.000Z","path":"2016/03/23/开始我的hexo博客/","text":"很早就有写博客的想法了，今天终于用hexo搭起了自己的博客，记录一下过程： 安装hexo使用nvm安装Node.js 1$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js 1$ nvm install 4 安装Hexo 1$ npm install -g hexo-cli 安装部署到git的插件 1$ npm install hexo-deployer-git --save 配置Github创建名为yourname.github.io的repository开启gh-pages功能 配置hexo按照hexo官网上的配置步骤进行注意配置_config.yml中的language选项时，需要看主题中language/里的语言文件 使用Next主题123$ cd theme/$ git clone https://github.com/iissnan/hexo-theme-next.git$ vim ../_config.yml 将theme:改为theme: hexo-theme-next 部署到Github修改配置完成后执行下列语句，生成代码 1$ hexo g 执行下列语句，部署到Github上 1$ hexo d","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]